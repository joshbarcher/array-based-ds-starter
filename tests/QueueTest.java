import adts.IQueue;
import org.junit.Assert;
import org.junit.Before;
import org.junit.Test;

import java.util.NoSuchElementException;

import static org.junit.Assert.*;

/**
 * Tests an implementation of the IBoundedQueue interface.
 *
 * DO NOT EDIT THIS FILE!
 *
 * @author Josh Archer
 * @version 1.0
 */
public class QueueTest
{
    private IQueue queue;

    //test elements
    private int[] testArray = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    private int[] missing = {11, 12, 13};

    /*
        This method should create and return a new queue
        for the methods below.
     */
    private IQueue createQueue()
    {
        //instantiate your class here!
        return null;
    }

    /**
     * Creates a new queue before each of the tests below.
     */
    @Before
    public void setup()
    {
        queue = createQueue();
    }

    /**
     * Verifies that the capacity defaults to 10 positions in the queue.
     */
    @Test
    public void capacityAccurateTest()
    {
        assertEquals("Capacity inaccurate when creating a queue with capacity 5",
                            10, queue.getCurrentCapacity());
    }

    /**
     * Verifies that
     */
    @Test
    public void fullQueueResizesTest()
    {
        addElementsToFullQueue();

        //one too many for a queue of size 5
        queue.add(11);
        assertEquals(11, queue.size());
    }

    /**
     * Verifies that you cannot remove an element from
     * an empty queue.
     */
    @Test(expected = NoSuchElementException.class)
    public void emptyQueueTest()
    {
        //remove a missing element
        queue.remove();
    }

    /**
     * Verifies that an element can be removed from the queue.
     */
    @Test
    public void removeTest()
    {
        addElementsToFullQueue();

        //remove the element
        int removed = (int)queue.remove();
        assertEquals("Added a single element, but didn't receive the " +
                            "element with remove()", 1, removed);
    }

    /**
     * Verifies that elements are returned in FIFO order.
     */
    @Test
    public void fifoTest()
    {
        addElementsToFullQueue();

        //make sure elements removed are in FIFO order
        for (int i = 0; i < testArray.length; i++)
        {
            assertEquals("Removed element does not match FIFO order",
                                testArray[i], queue.remove());
        }
    }

    /**
     * Verifies that elements that are in the queue
     * can be found
     */
    @Test
    public void containsExistsTest()
    {
        addElementsToFullQueue();

        //make sure elements are discoverable
        for (int i = 0; i < testArray.length; i++)
        {
            assertTrue("Added element not discoverable by contains()",
                                queue.contains(testArray[i]));
        }
    }

    /**
     * Verifies that missing elements are not found with
     * contains().
     */
    @Test
    public void containsMissingTest()
    {
        addElementsToFullQueue();

        //make sure elements are discoverable
        for (int i = 0; i < missing.length; i++)
        {
            assertFalse("Missing element is discoverable by contains()",
                                queue.contains(missing[i]));
        }
    }

    /**
     * Verifies that missing elements cannot be found
     * with contains() on an empty queue.
     */
    @Test
    public void containsOnEmptyQueueTest()
    {
        //contains should always return false on empty queue
        assertFalse("Missing element is discoverable by contains()",
                            queue.contains(9));

        //add an element and confirm contains() can discover it
        queue.add(9);
        assertTrue("Element added to queue is not discoverable by contains()",
                            queue.contains(9));
    }

    /**
     * Verifies that a missing element results in an exception.
     */
    @Test(expected = UnsupportedOperationException.class)
    public void removeElementTest()
    {
        //this should always result in an exception
        queue.remove(2);
    }

    /**
     * Verifies that the size of the queue is reported correctly
     * for an empty queue.
     */
    @Test
    public void initialStateTest()
    {
        //queue should be empty to start with
        assertEquals("Queue should have size 0 when created", 0, queue.size());
        assertTrue("Queue should be empty when created", queue.isEmpty());
    }

    /**
     * Verifies that a queue with elements can report
     * how many are present correctly.
     */
    @Test
    public void sizeTest()
    {
        addElementsToPartialQueue();

        //queue should be empty to start with
        assertEquals("Queue size not correct after a few calls to add()",
                            testArray.length / 2, queue.size());
        assertFalse("Queue should not be empty after calling add()", queue.isEmpty());
    }

    /**
     * Verifies that isFull() reports correctly for an empty queue.
     */
    @Test
    public void notFullTest()
    {
        assertTrue("Empty queue should be empty", queue.isEmpty());
        assertFalse("An empty queue should not be full", queue.isFull());
    }

    /**
     * Verifies that isFull() reports correctly for a partially full queue.
     */
    @Test
    public void semiFullTest()
    {
        addElementsToPartialQueue();

        assertEquals("Queue size not correct after a few calls to add()",
                            testArray.length / 2, queue.size());
        assertFalse("A partially filled queue should not be full", queue.isFull());
    }

    /**
     * Verifies that isFull() reports correctly for a full queue.
     */
    @Test
    public void fullTest()
    {
        addElementsToFullQueue();

        assertTrue("Queue should be full once size is the same as capacity", queue.isFull());
    }

    /**
     * Verifies that the size is reported correctly after calling
     * clear on an empty queue.
     */
    @Test
    public void clearEmptyTest()
    {
        //make sure no errors are encountered
        queue.clear();

        assertEquals("Queue size should be 0 after calling clear()", 0, queue.size());
        assertTrue("Queue should be empty after calling clear", queue.isEmpty());
        assertFalse("Queue should be empty after calling clear", queue.isFull());
    }

    /**
     * Verifies that the size is reported correctly after calling
     * clear on a non-empty queue.
     */
    @Test
    public void clearNotEmptyTest()
    {
        addElementsToPartialQueue();

        //make sure no errors are encountered
        queue.clear();

        assertEquals("Queue size should be 0 after calling clear()", 0, queue.size());
        assertTrue("Queue should be empty after calling clear", queue.isEmpty());
    }

    /**
     * Verifies that the queue behaves as expected when given
     * a large number of elements.
     */
    @Test
    public void largeQueueTest()
    {
        //add a few elements
        for (int i = 1; i <= 1000; i++)
        {
            queue.add(i);
        }

        assertEquals("Queue should have a size of 1000 after 1000 additions", 1000, queue.size());
        assertFalse("Queue should not be empty after 1000 additions", queue.isEmpty());

        //elements should be returned in order
        for (int i = 1; i <= 1000; i++)
        {
            assertEquals("Elements not returned in FIFO order", queue.remove(), i);
        }
    }

    /**
     * Verifies that intermixed calls to add() and remove()
     * behave correctly.
     */
    @Test
    public void regularModificationsTest()
    {
        //repeatedly add/remove elements
        for (int i = 1; i <= 4; i++)
        {
            //add 2
            int[] elemsToAdd = {2, 4};
            for (int j = 0; j < elemsToAdd.length; j++)
            {
                queue.add(elemsToAdd[j]);
            }

            //remove 1
            for (int j = 0; j < elemsToAdd.length - 1; j++)
            {
                queue.remove();
            }
        }

        //There should be four net elements in the end
        assertEquals("The number of elements left in the queue after repeatedly " +
                            "calling add() and remove() is incorrect", 4, queue.size());
        assertFalse("The queue should not be empty after repeatedly calling add() and remove()",
                            queue.isEmpty());
    }

    /**
     * Verifies that add works correctly after removing all
     * elements from the queue.
     */
    @Test
    public void addAfterEmptyingQueueTest()
    {
        addElementsToFullQueue();

        for (int i = 0; i < testArray.length; i++)
        {
            queue.remove();
        }

        //add a single element after emptying the queue
        queue.add(8);
        assertEquals("Queue should have a size of 1 after adding a single " +
                            "element to a 'recently' emptied queue", 1, queue.size());
        assertTrue("Queue should detect a single element after emptying the queue",
                            queue.contains(8));
    }

    private void addElementsToFullQueue()
    {
        for (int i = 0; i < testArray.length; i++)
        {
            queue.add(testArray[i]);
        }
        assertEquals("The size of your queue should be " + testArray.length +
                            " after calling add() " + testArray.length + " times",
                            testArray.length, queue.size());
    }

    private void addElementsToPartialQueue()
    {
        int length = (testArray.length / 2);
        for (int i = 0; i < testArray.length / 2; i++)
        {
            queue.add(testArray[i]);
        }
        assertEquals("The size of your queue should be " + length +
                            " after calling add() " + length + " times",
                            length, queue.size());
    }
}


