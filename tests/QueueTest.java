import adts.IQueue;
import org.junit.Before;
import org.junit.Test;

import java.util.*;

import static org.junit.Assert.*;

/**
 * Tests an implementation of the IBoundedQueue interface.
 *
 * DO NOT EDIT THIS FILE!
 *
 * @author Josh Archer
 * @version 1.0
 */
public class QueueTest
{
    private Random random = new Random();
    private IQueue queue;

    //test elements
    private Set<Integer> missingElements = Set.of(11, 12, 13);

    /*
        This method should create and return a new queue
        for the methods below.
     */
    private IQueue createQueue()
    {
        //instantiate your class here!
        return null;
    }

    /**
     * Creates a new queue before each of the tests below.
     */
    @Before
    public void setup()
    {
        queue = createQueue();
    }

    /**
     * Verifies that the capacity defaults to 10 positions in the queue.
     */
    @Test
    public void capacityAccurateTest()
    {
        assertNotEquals("Capacity inaccurate when creating an empty queue",
                            0, queue.getCurrentCapacity());
    }

    /**
     * Verifies that
     */
    @Test
    public void fullQueueResizesTest()
    {
        List<Integer> added = addElementsToFullQueue();

        //add one more after reaching the capacity (to force a resize)
        queue.add(99);
        assertEquals(added.size() + 1, queue.size());
    }

    /**
     * Verifies that you cannot remove an element from
     * an empty queue.
     */
    @Test(expected = NoSuchElementException.class)
    public void emptyQueueTest()
    {
        //remove a missing element
        queue.remove();
    }

    /**
     * Verifies that an element can be removed from the queue.
     */
    @Test
    public void removeTest()
    {
        List<Integer> added = addElementsToFullQueue();

        //remove the element
        int removed = (int)queue.remove();
        assertEquals("Added a single element, but didn't receive the " +
                            "element with remove()", added.get(0).intValue(), removed);
    }

    /**
     * Verifies that elements are returned in FIFO order.
     */
    @Test
    public void fifoTest()
    {
        List<Integer> added = addElementsToFullQueue();

        //make sure elements removed are in FIFO order
        for (int i = 0; i < added.size(); i++)
        {
            assertEquals("Removed element does not match FIFO order",
                    added.get(i).intValue(), queue.remove());
        }
    }

    /**
     * Verifies that elements that are in the queue
     * can be found
     */
    @Test
    public void containsExistsTest()
    {
        List<Integer> added = addElementsToFullQueue();

        //make sure elements are discoverable
        for (int i = 0; i < added.size(); i++)
        {
            assertTrue("Added element not discoverable by contains()",
                                queue.contains(added.get(i).intValue()));
        }
    }

    /**
     * Verifies that missing elements are not found with
     * contains().
     */
    @Test
    public void containsMissingTest()
    {
        addElementsToFullQueue();

        //make sure elements are discoverable
        for (int element : missingElements)
        {
            assertFalse("Missing element is discoverable by contains()",
                                queue.contains(element));
        }
    }

    /**
     * Verifies that missing elements cannot be found
     * with contains() on an empty queue.
     */
    @Test
    public void containsOnEmptyQueueTest()
    {
        //contains should always return false on empty queue
        assertFalse("Missing element is discoverable by contains()",
                            queue.contains(9));

        //add an element and confirm contains() can discover it
        queue.add(9);
        assertTrue("Element added to queue is not discoverable by contains()",
                            queue.contains(9));
    }

    /**
     * Verifies that a missing element results in an exception.
     */
    @Test(expected = UnsupportedOperationException.class)
    public void removeElementTest()
    {
        //this should always result in an exception
        queue.remove(2);
    }

    /**
     * Verifies that the size of the queue is reported correctly
     * for an empty queue.
     */
    @Test
    public void initialStateTest()
    {
        //queue should be empty to start with
        assertEquals("Queue should have size 0 when created", 0, queue.size());
        assertTrue("Queue should be empty when created", queue.isEmpty());
    }

    /**
     * Verifies that a queue with elements can report
     * how many are present correctly.
     */
    @Test
    public void sizeTest()
    {
        List<Integer> added = addElementsToPartialQueue();

        //queue should be empty to start with
        assertEquals("Queue size not correct after a few calls to add()",
                added.size(), queue.size());
        assertFalse("Queue should not be empty after calling add()", queue.isEmpty());
        assertFalse("A partially filled queue should not be full", queue.isFull());
    }

    /**
     * Verifies that isFull() reports correctly for an empty queue.
     */
    @Test
    public void notFullTest()
    {
        assertTrue("Empty queue should be empty", queue.isEmpty());
        assertFalse("An empty queue should not be full", queue.isFull());
    }

    /**
     * Verifies that isFull() reports correctly for a full queue.
     */
    @Test
    public void fullTest()
    {
        addElementsToFullQueue();

        assertTrue("Queue should be full once size is the same as capacity", queue.isFull());
    }

    /**
     * Verifies that the size is reported correctly after calling
     * clear on an empty queue.
     */
    @Test
    public void clearEmptyTest()
    {
        //make sure no errors are encountered
        queue.clear();

        assertEquals("Queue size should be 0 after calling clear()", 0, queue.size());
        assertTrue("Queue should be empty after calling clear", queue.isEmpty());
        assertFalse("Queue should be empty after calling clear", queue.isFull());
    }

    /**
     * Verifies that the size is reported correctly after calling
     * clear on a non-empty queue.
     */
    @Test
    public void clearNotEmptyTest()
    {
        addElementsToPartialQueue();

        //make sure no errors are encountered
        queue.clear();

        assertEquals("Queue size should be 0 after calling clear()", 0, queue.size());
        assertTrue("Queue should be empty after calling clear", queue.isEmpty());
    }

    /**
     * Verifies that the queue behaves as expected when given
     * a large number of elements.
     */
    @Test
    public void largeQueueTest()
    {
        //add a few elements
        for (int i = 1; i <= 1000; i++)
        {
            queue.add(i);
        }

        assertEquals("Queue should have a size of 1000 after 1000 additions", 1000, queue.size());
        assertFalse("Queue should not be empty after 1000 additions", queue.isEmpty());

        //elements should be returned in order
        for (int i = 1; i <= 1000; i++)
        {
            assertEquals("Elements not returned in FIFO order", queue.remove(), i);
        }
    }

    /**
     * Verifies that intermixed calls to add() and remove()
     * behave correctly.
     */
    @Test
    public void regularModificationsTest()
    {
        //repeatedly add/remove elements
        for (int i = 1; i <= 4; i++)
        {
            //add 2
            int[] elemsToAdd = {2, 4};
            for (int j = 0; j < elemsToAdd.length; j++)
            {
                queue.add(elemsToAdd[j]);
            }

            //remove 1
            for (int j = 0; j < elemsToAdd.length - 1; j++)
            {
                queue.remove();
            }
        }

        //There should be four net elements in the end
        assertEquals("The number of elements left in the queue after repeatedly " +
                            "calling add() and remove() is incorrect", 4, queue.size());
        assertFalse("The queue should not be empty after repeatedly calling add() and remove()",
                            queue.isEmpty());
    }

    /**
     * Verifies that add works correctly after removing all
     * elements from the queue.
     */
    @Test
    public void addAfterEmptyingQueueTest()
    {
        List<Integer> added = addElementsToFullQueue();

        for (int i = 0; i < added.size(); i++)
        {
            queue.remove();
        }

        //add a single element after emptying the queue
        queue.add(8);
        assertEquals("Queue should have a size of 1 after adding a single " +
                            "element to a 'recently' emptied queue", 1, queue.size());
        assertTrue("Queue should detect a single element after emptying the queue",
                            queue.contains(8));
    }

    private List<Integer> addElementsToFullQueue()
    {
        int capacity = queue.getCurrentCapacity();
        return addElements(capacity);
    }

    private List<Integer> addElementsToPartialQueue()
    {
        int capacity = queue.getCurrentCapacity();
        int elements = capacity / 2;
        return addElements(elements);
    }

    private List<Integer> addElements(int number)
    {
        List<Integer> addedElements = new ArrayList<>();

        for (int i = 0; i < number; i++)
        {
            int element = getRandomElement();
            queue.add(element);
            addedElements.add(element);
        }
        assertEquals("The size of your queue should be " + number +
                        " after calling add() " + number + " times",
                number, queue.size());

        return addedElements;
    }

    private int getRandomElement()
    {
        int result;
        do
        {
            result = random.nextInt();
        } while (missingElements.contains(result));
        return result;
    }
}


